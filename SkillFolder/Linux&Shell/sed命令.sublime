sed   文中的[]方括号是表示可选项，而不是需要输入的
	sed -option 'script'|file target_process_file
**sed是按照读入数据的每一行读到模式空间，除非行被删除或被合并到当前行。
  插入，更新，打印也都是在模式空间内操作，而不会影响原文件行的读入
# option 默认为e 直接读取后续脚本,且可以多个命令用分号；分割
	如sed -e 's/brown/green/; s/dog/cat/' file
  f 读取脚本文件 ； n不显示输出
# |符号表示或
# 如果不指定target file 则从STDIN输入，并以CONTROL-D 结束 表示EOF信号
# {program} 内部使用分号区分同行命令，如果是多行但可以不用分号， 单一命令可以直接使用 'command' ,不用大括号'{ }' 
# 'script' 脚本中使用 [address|/模式/]{command} 的格式编辑内容
	# [address|/模式/] 将符合的行逐条读入**模式空间**内  
	# /模式/ 多个匹配模式中可使用,逗号 分割多个模式 /patt1/,/patt2/， 但其表示：第一个模式开始指令，后一个模式结束指令，而不是分别匹配

	[address]: 使后续命令应用于选定的行 $代表最后一行
		行号 ；
		起始行号，结束行号；
		起始航海，$  --- $表示最后一行

	替换字符
		[address|/模式/]s/模式/替换字符/flags  (模式中的（）需要用\( \)  \ 转义字符)
		（当模式或替换字符中有/正斜线时，可使用任意其他字符作为区分符如！ s!模/式!替换/字符!flags ）

		flags: n:一个数字，表示替换第几处匹配的内容， 默认只替换第一处
			   g: 替换所有文本
			   p: 打印当前模式空间中的内容
			   w file: 将符合模式的行替换后的内容写入到目标文件

			s/模式/替换字符/flags 中替换字符的如果要使用模式匹配的字符，
			a. 可使用& 代替模式匹配中的全部匹配的字符
			b. 在使用模式匹配时可以使用
				. 句点匹配单一字符，
			   	* 表示重复多个前一匹配符，
			   	而在替换字符则只表示一个标点符号，不做任何匹配
			c.  当模式中使用\(子模式\） 子模式时， 可以用\1 ,\2 匹配字模式中的字符 
				sed 's/\(System\) Administrator/\1 User/'' \1表示System ，
				\( \）是子模式提示符



		[address|/模式/]y/inchar/outchar/ 将inchar替换为outchar中相对应的字符 （注意是字符）inchar长度必须等于outchar
			y/123/456/  4替换所有1


	删除命令
		[address|/模式/]d 删除当前模式空间中的值，不论模式空间中有几行

		[address|/模式/]D 删除当前模式空间中的换行符 \n之前的行


	插入附加修改命令 **不会影响模式空间的内容，就是模式空间仍是文件原有的内容，而不会随着新内容变化** 
		sed '[address|patt]i\newline\..' file|管道命令传入的值 将newline这一行插入到定位的行之 前 或管道命令传入值之 前 
		sed '[address|patt]a\newline\..' file|管道命令传入的值 将newline这一行插入到定位的行之 后 或管道命令传入值之 后

		sed '[address|patt]r filename' file|管道命令的值 将filename中的行插入到定位的行之 后 或管道命令传入值之 后

		sed '[address|patt]c\newline\..' file|管道命令的值 将newline这一行替换为定位的行可



		可按顺序插入多行

	打印
		[address|/模式/]p 打印符合匹配的行， 注意与替换字符flag中p的区别，替换字符中的p是打印替换之后的行内容
		= 打印行号，且每个行号后有换行符
		l 将行内容打印出ascii字符，包含不可见字符


		[address|/模式/]P 打印符合匹配的行中\n之前的行。

	写入文件 （后面的命令可能懒得写[address|patt] 部分了，除了不可用外，其他都会有）
		[address|patt]w target 文件 将符合文件目录写入文件


扩展模式空间与保持空间， 


		next使用下一行 替换 到模式空间命令 sed '[address|/模式/]n' 将符合条件的行的下一行记录读入到模式空间中 并应用处理
		如 line1
		   line2
		   line3
		   line4
		 如果不指定范围，则执行顺序为
		 先读入line1，遇到n命令，将line2读入，应用修改到line2，
		 读入line2（只要line2没被删除或合并，仍会读入），遇到n命令，将line3读入，应用修改到line3；以此类推，最后只有line1没有应用修改
		 但读入line4时因为没有下一行，回报错，所以使用 !$n 表示最后一行不应用n命令，但执行后续命令，
		 记住命令应用于模式空间即可；

	多行处理
		Next读入下一行 追加 到模式空间命令 sed '[address|/模式/]N' 将符合条件的行的下一行记录读入到模式空间中 并应用处理
		如 line1
		   line2
		   line3
		   line4
		 如果不指定范围，则执行顺序为
		 先读入line1，遇到N命令，将line2读入，应用修改到line2，
		 读入line2，遇到N命令，将line3读入，应用修改到line3；以此类推，最后只有line1没有应用修改
		 但读入line4时因为没有下一行，会报错，所以使用 $!N 表示最后一行不应用N命令，但执行后续命令，
		 记住命令应用于模式空间即可；


	反向命令
		[address|/模式/]!command  将command应用到所有不符合模式地址的行数

	保持空间：默认保持空间一行 空文件行
		h 将模式空间替换到保持空间 H 将模式空间追加到保持空间之后
		g 将保持空间替换到模式空间 G 将保持空间追加到模式空间之后 
		x 模式空间与保持空间交换


标签分组
	[address|/模式/]b [:label] : 将符合address或模式符合的行转跳至label标记的地方并应用label之后的命令
							 **label最长7个字符， 没有label时，则什么都不会执行
	如果b命令在最后且有标签时，模式空间永远不会读入下一行，只会在同一行多次执行，造成死循环
	例
	 {2,3b jump1; command1 ; :jump1 ;command2} 2,3 行只会应用command2， 的其他行应用command1 及command2  ---记住标签位要使用:


	 [替换commnad]t :label : 替换命令如果匹配且成功，则转跳至label的位置，并执行后续命令，没有label，则跳至脚本结尾，什么都不执行，并读入下一行。
	 	    如果没有匹配成功，则执行t之后的命令。
	  if 替换command 成功 then goto label及之后命令 else 失败 t之后的命令。
	  


