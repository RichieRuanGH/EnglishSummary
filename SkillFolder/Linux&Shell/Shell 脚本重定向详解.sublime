Shell 脚本重定向详解 （理解链表的方式，保持多重引用）

1. 基本方式
	< 输入重定向符   文件符0 代表键盘输入进程文件符  默认 0< 可修改为其他输入并传给命令 cat < filename 
					从filename逐字符传入  
	> （ 1> ） 非错误标准输出重定向符（如echo的输出or命令成功的输出）
			  文件符1表示非错误标准输出的进程文件符，其对应的输出方式是显示器 
		>>  追加内容； 
		使用> 将非错误输出定向到其他文件 而不是 显示器
	2> 错误重定向 文件符2表示标准错误输出进程的文件符，其对应输出方式为显示器 
	    使用2> 将错误输出重定向到其他文件 而不是 显示器

	&> 表示： >和2> 合体

	文件符与定向符号 < 和>中间没有空格 



	***** 一定注意 文件符0 ，1，2 和重定向0< 1> 2>中的数字是一一对应关系*********
	***** 0<默认形式为  标准输入是从键盘输入 记录在标准输入文件符0，并由文件符0传给命令 cat <-- 0<（其定向到）键盘 *******
	***** 1>默认形式为  标准（非错误）输出 记录在文件符1 --> 1>（其定向到） 显示器     *******
	***** 2>默认形式为  错误输出 记录在文件符2 --> 2>（其定向到） 显示器     *******
	***** &0,&1,&2....表示文件符当前所指的定向 ******** 

2. 脚本中重定向
	0. 默认脚本中所有的echo 及相关命令都是默认指向 &1 文件符1对应的定向
	a. 临时重定向 将输出指定到特定文件符  echo "xxxxx" >&2 默认输出到文件符1的定向，改为输出到错误输出文件符2的定向
	   如果执行脚本 a. 未指定 错误输出定向， 则xxxx内容仍显示在显示器
			      b. 如果指定了 错误重定向到其他文件 2> filename ,则xxxx将输出到filename文件中；

	b. 脚本中永久重定向 exec 1>filename  ; exec 2>filename :  exec 0< filename
					 将文件符1 和文件符2的输出重定向到文件, 将文件符0的输入定向到filename，再由0传给命令

3. 自定义文件符 3~8 
	a.文件符3~8与系统自定义的 0~2相似， 只要在exec中定义即可
		exec 3>filename #表示定义了一个新的输出文件符3，且其输出为 filename文件
		echo 'xxxxxx' >&3 表示将输出从默认非错误输出文件符1的定向 改到文件符3的定向


	b.对于自定义文件符3~8因为没有默认的输出方式（即无法定义到显示器）所以通过文件符1or2 挂到默认显示器，
	  并且也可以在重定义1> 2>后再改回 默认显示器  
	  exec 3>&1  		#表示定义新的文件符3 并将其输出定向到 文件符1当前的定向 即显示器
	  exec 1>filename 	#修改文件符1的定向到filename ，其后echo 到默认文件符1的输出都默认输出到新的定向filename
	  exec 1>&3   		#将文件符1的输出重新定向到 文件符3当前输出的定向 即显示器

	  /dev/tty 为显示器设备， exec >/dev/tty 即为将标准输出重定向到显示器

	c.类似定义输入文件符 
		exec 6<&0  #表示定义一个输入文件符6， 且其定向为 文件符0的输入定向 即键盘
		exec 0< textfile # 表示将文件符0的输入定向修改为 textfile ，之后read 命令的的读入都是从textfile读入
		exec 0<&6  #表示将输入文件符0的定向修改为 文件符6的输入定向 即键盘


	d.双向文件符 (指定文件符的含义)
		exec 4<> textfile 
		exec read line <&4     #= exec 0<&4  表示将将输入文件符0的定向修改为 文件符4的输入 txtfile；
		echo 'xxxx' >&4        #= exec 1>&4  将默认输出到文件符1的定向，改为输出到错误输出文件符4的定向 即textfile

	e.关闭文件符 
		3>&- 表示关闭文件符

	f.列出可用的文件符
		lsof -a -p $$ -d 0,1,2  # a表示符合-p和-d的两个条件的记录， -p指定$$的pid  -d指定的文件符

	g。 >/dev/null 定向到空 



