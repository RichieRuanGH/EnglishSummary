Linux Shell编程技巧

1. 算数命令
	传统expr 
		脚本文件中需要对某些字符使用转义符 如 \*
		赋值给变量时需要使用 $(expr ) 命令替换

	$[express] 可直接使用符号计算无需\转义  =$(( ))
	$( ) 与 ` ` (反引号)： 在范围中的命令可以返回命令结果
	反引号对\进行了转义，保留了其本身的意思，如果要在反引号中起到\，必须加两个\
	$()没有对其转义

	bc --计算器工具 bc -q： 不显示欢迎词

2. shell内部关键变量
	IFS = '\n' 或者 "\n"    ---单，双引号表示一组字符串数组， 表示 \ 和n 都是字符串的分隔符
	IFS = $“\n”    ---$“\n ” 同上
	举例 str = 'a\nb\nc\nd'
	echo 将str转换为 a '' b '' c '' d
	\n 被视为两个单独的字符，都是表示分分隔，当有多个分隔是，合并为一个''空字符


	IFS = $'\n'    ---$'' 表示一个不显性特殊字符， 表示换行符为分隔符
	举例 str = 'a\nb\nc\nd'
	echo 将str转换为 'a\nb\nc\nd'
	并且直接打印为  'a\nb\nc\nd'
	只有 str = 'a
	b'
	echo 识别不可见回车符为分隔符 ，将打印为‘a b'


	export variable 将variable从局部变量导出为全局变量

2.1 Linux系统中的引用符号
	'' : 单引号强引用，除了 自身单引号不可显示外，其他任何字符都当做普通字符显示
	"": 双引号弱引用，对于自身和特殊字符，需用\ 转义显示；而且可识别反引号与变量符号
		但可以直接显示单引号

	$' ': 带$前置的单引号 = echo -e  表示将实现引用中的特殊转义序列


3. $ 符号作用
	a. 参数类应用 $var 与${var} 相同，${ } 更准确判定范围;解析数组时建议使用${}
	shell脚本中-自定义变量 可使用$var 进行取值操作
			      -命令行引入参数 $0 ~9 当超过10的时候 ${10}..
	  		  -特殊变量$# 表示除文件名$0 之外的参数个数 ${!#} 表示最后一个变量(${} 中不允许使用$ 符号，所以用！替代)
				 -$* 将$0之外的参数当做一个字符串整体
				 -$@ 将$0之外的参数一组单词的数组， 作为列表时使用“$@”进行调用
				 -$$ 脚本中传入系统分配的PID
				 -$? 函数、命令等执行后的返回状态码


	b. 代码替换类
	$( ) 与 ` ` (反引号)： 在范围中的命令可以返回命令结果
	反引号对\进行了转义，保留了其本身的意思，如果要在反引号中起到\，必须加两个\
	$()没有对其转义

	$[ ] 与 $(( )) –整数基础算数运算， 高级算数运算且可以不使用转义符号
	另$((16#ff)) 可以将ff转换为10进制；

	[ ] 与test：条件判断语句的condition判断,判断结果为是与否， 特殊符号需要转义符

	[[ ]] 与 (( )) : 
	[[ ]] 对于[] 文本模式的增强，增加文本匹配模式 如 [[ $VAR == r* ]]； 
	(( ))：1. 加强对算数判断的增强
		2. 可使用自增符号重定义变量 ((a+))
		3. for循环条件中C语言形式的条件 (( i=x; i<=target; i++ ))

	c. ${ }高级应用
		1. 先赋值一个变量为一个路径，如下：
		file=/dir1/dir2/dir3/my.file.txt

		命令    		  解释    					   结果
		${file#*/}    拿掉第一条 / 及其左边的字符串    dir1/dir2/dir3/my.file.txt
		[root@localhost ~]# echo ${file#*/}
		dir1/dir2/dir3/my.file.txt

		${file##*/}    拿掉最后一条 / 及其左边的字符串    my.file.txt
		[root@localhost ~]# echo ${file##*/}
		my.file.txt

		${file#*.}    拿掉第一个 . 及其左边的字符串    file.txt
		[root@localhost ~]# echo ${file#*.}
		file.txt

		${file##*.}    拿掉最后一个 . 及其左边的字符串    txt
		[root@localhost ~]# echo ${file##*.}
		txt


		${file%/*}    拿掉最后一条 / 及其右边的字符串    /dir1/dir2/dir3
		[root@localhost ~]# echo ${file%/*}
		/dir1/dir2/dir3

		${file%%/*}    拿掉第一条 / 及其右边的字符串    (空值)
		[root@localhost ~]# echo ${file%%/*}
		(空值)

		${file%.*}    拿掉最后一个 . 及其右边的字符串    /dir1/dir2/dir3/my.file
		[root@localhost ~]# echo ${file%.*}
		/dir1/dir2/dir3/my.file

		${file%%.*}    拿掉第一个 . 及其右边的字符串    /dir1/dir2/dir3/my￼
		[root@localhost ~]# echo ${file%%.*}
		/dir1/dir2/dir3/my
		记忆方法如下：

		# 是去掉左边(在键盘上 # 在 $ 之左边)
		% 是去掉右边(在键盘上 % 在 $ 之右边)
		单一符号是最小匹配;两个符号是最大匹配
		*是用来匹配不要的字符，也就是想要去掉的那部分
		还有指定字符分隔号，与*配合，决定取哪部分

		2. 取子串及替换
		命令                             解释                           　　 结果
		${file:0:5}            　　　提取最左边的 5 个字节    　　　　　　　　　　　　/dir1
		${file:5:5}            　　　提取第 5 个字节右边的连续 5 个字节    　　　　　/dir2
		${file/dir/path}            将第一个 dir 提换为 path    　　　　　　　　　 /path1/dir2/dir3/my.file.txt
		${file//dir/path}    　　　　将全部 dir 提换为 path    　　　　　　　　　　　/path1/path2/path3/my.file.txt
		${#file}    　　　　　　　　　 获取变量长度    　　

		3. 根据状态为变量赋值
		命令					解释								备注
		${file-my.file.txt}	若 $file 没设定,则使用 my.file.txt 作传回值	空值及非空值不作处理
		${file:-my.file.txt} 若 $file 没有设定或为空值,则使用 my.file.txt 作传回值	非空值时不作处理
		${file+my.file.txt}	若$file 设为空值或非空值,均使用my.file.txt作传回值	没设定时不作处理
		${file:+my.file.txt} 若 $file 为非空值,则使用 my.file.txt 作传回值	没设定及空值不作处理
		${file=txt}	若 $file 没设定,则回传 txt ,并将 $file 赋值为 txt	空值及非空值不作处理
		${file:=txt}	若 $file 没设定或空值,则回传 txt ,将 $file 赋值为txt	非空值时不作处理
		${file?my.file.txt}	若 $file 没设定,则将 my.file.txt 输出至 STDERR	空值及非空值不作处理
		${file:?my.file.txt}	若 $file没设定或空值,则将my.file.txt输出至STDERR	非空值时不作处理
		 tips:
		以上的理解在于, 你一定要分清楚 unset 与 null 及 non-null 这三种赋值状态. 一般而言, : 与 null 有关, 若不带 : 的话, null 不受影响, 若带 : 则连 null 也受影响.

		4. 数组
		A="a b c def"   # 定义字符串
		A=(a b c def)   # 定义字符数组
		命令 	 	解释	 			结果
		${A[@]}		返回数组全部元素	a b c def
		${A[*]}		同上				a b c def
		${A[0]}		返回数组第一个元素	a
		${#A[@]}	返回数组元素总个数	4
		${#A[*]}	同上				4
		${#A[3]}	返回第四个元素的长度，即def的长度	3
		A[3]=xzy	则是将第四个组数重新定义为 xyz	 


4. 脚本参数处理方法
	set 作为系统变量变更和显示的方法，在shell脚本中 
		set -- variable  将variable作为新的参数替换掉原本传入的命令参数串

	getopt 将脚本传入的命令行与参数格式化 （比如聚集参数标准化为拆分的格式）
		getopt -o ab:cd -a -b test1 -cd para1 para2 
		转化成 -a -b test1 -c -d -- para1 para2  ## --破折号在这里是区分命令选项和参数的中间项
				getopt -o ab:cd -a -b test1 -cd -- para1 para2  ##也可以直接在命令中指定 -- 分割命令和参数
				ab:cd 是指定可接受的需要格式化的选项字符，如果后续参数并不在这个字符组中，则会报错，可用-q 避免报错
					  b: 字符后的冒号是指定 该选项后需要跟参数选项，一般按照参数出现顺序指定；
					  b:: 两个冒号表示可接受0 or 1个参数

		getopt --long --arg --argb   ## -o 是默认短命令， --long 是指定长命令

		配合 set 使用  set -- $(getopt ab:cd "$@") ##将格式化后的参数命令替换 原有脚本命令参数

	getopts: 高级getopt: 只处理选项ß，不处理后续参数； 
	getopt 将命令行转化为标准字符串格式 ； getopts 将命令行转化为存在某一变量的递增参数
		getopts optstring target_var 
			## optstring为需要处理的命令选项字符组 如 :ab:cd 
			## target_var 为存储命令选项字符 ， 且解析后的字符不包含 -破折号 如 ab -> a b
			## b: 字符后的冒号是指定 该选项后需要跟参数选项，一般按照参数出现顺序指定,
				且参数支持 “xxx  xxxx” 双引号内的一组有空格的字符串 ，getopt不支持
			## :ab: 整个optstring字符前的冒号表示 如果有错误也不显示
			## 当后续命令行不包含在optstring指定的字符组中，则将其转换为 ？ 问号

			## 关键变量 OPTIND OPTARG OPTERR
				OPTIND: 初始值为1，每读取一个命令选项则+1， 
						配合shift $[ $OPTIND-1 ]使用，当全部命令读取完后，将参数行中命令选项全部移除，保留后续的参数值

				OPTARG: 由 getopts 找到的选项所对应的参数，当遇到选项有: 冒号时，将后续的参数 保存在OPTARG
						在getopt中则是按照命令行逐个显示
				OPTERR: 值为0或1。指示Bash是否应该显示由 getopts 产生的错误信息。


5. shell函数
	##定义函数与使用
	a. 
	function func1 {
	 	commands
	} 

	b.
	func1() {
		commands
	}

	调用方法统一 ： func1   ##不需要包含()
	
	##返回数据
		a. 函数执行后的默认返回状态码 （是否成功）
		b. return 返回指定状态码 但范围 0~255
		c。 $(func1) 返回函数中使用echo 返回的值 作为输出的值

	##传入使用变量
		在定义函数时不需要声明参数， 而是在func后直接接需要传入的参数
		func1 var1 var2 
		在函数内定义时， 使用与shell一样的 $#,$1,$2 代表传入的参数
		***** 注意 : $#,$1,$2 与脚本命令传入的参数并不是同一套参数变量 注意******

	##局部与外部变量
		默认所有定义变量都是全局通用，
		在函数内部可用 local temp 指定为函数内局部变量

	##数组传递与传出
		当需要从外部传入数组myarray时， 需要将数组逐个读取${myarray[*]}转为一系列变量传入，再有$@ 将变量打包成一组可递归的参数变量组传入
		最后使用 （；`echo "$@"`|$(echo "$@") ） 将$@数组逐个解析成值 并用最外层的（ ） 转成数组赋给局部变量
		例
		local inarray
		inarray = （`echo "$@"`|$(echo "$@") ）  #此时inarray就是一个数组
		解析时用 echo ${inarray[*]}|“xxxxx ${inarray[*]}” 读取全部数组元素

		传出数组
		函数内部使用 echo ${resultarray[*]} 将数组逐个打印 
		在外部使用变量接收 并转为数组 result = （func var1 var2 var3... ） 

	##可以将函数集中在一个文件中做成库文件，当其他shell脚本需要调用时，指定库文件路径并使用 source 或. 执行文件即可


6. shell脚本执行方法（. source 与 bash/sh ./ 或直接运行）
	需要 执行权限与文件头指定执行方式 #！：
		./bash_file  执行当前目录下的shell脚本；
		直接执行 bash_file  如在文件目录外执行需要将目录加入环境变量
		.与source 作用相同 指定shell脚本在当前环境执行，不再另开子环境

	不需要执行权限与文件头:
		bash bash_file  : 指定程序执行， bash_file可视为bash的参数
		sh 是bash的别名，作用相同。


7. fork与source与exec 与export 
	
	export是脚本中临时设定环境变量的

	source: 不开子shell环境，直接在当前环境执行脚本

	fork: 开设子环境 等同于 ./ 与直接执行 的方式调用脚本（外部命令，内建命令不会创建子进程执行）， 执行完后返回父环境；

	exec：与source相同 不开设子shell环境，直接在当前环境执行，但exec执行完后直接退出，不继续执行剩余的脚本；
	另 exec还可以自定义重定向 参考另一篇文章

	command;command;  当多命令连续执行时，并不创建子进程  相当于 {cmd; cmd; }
	(command;command;)  而当使用 ()时，会创建子进程进行运行
	所以（）可以强制使用子进程运行命令

7.a 创建子进程的几种方式
		./ or fork() or 直接执行外部命令 都会创建子进程
			**执行内建命令直接在当前shell调用，不创建子进程
		（cmd;cmd; ) 强制使用子进程执行
		coproc cmd 会创建子进程名自动转入后台& 工作，当coproc 
			()联合使用时，（）会coproc中再创建另一层子进程，形成嵌套 

7.b 子进程执行的过程与方式 （Linux Shell 实例精解P10-P20）
	1. fork() 创建新的子进程，从父进程拷贝所有环境
	2. 调用wait()使父进程暂时挂起，直到子进程终止，返回子进程PID和退出状态
	3. 然后子进程中再调用命令 exec command ，将程序朱装入子程序的内存（相当于覆盖子进程）
		运行完后，直接退出进程并且父进程被唤醒
	4. 子进程退出后执行exit() 释放资源，返回退出码

7.c 管道与重定向命令中的子进程
	管道与重定向都会将父进程的文件说明符传递给子进程；
	在父进程建立一个管道命令后， 管道| 两侧的命令会分别创建两个子进程
	一个进程写入管道，一个进程读取管道，管道是kernel一块被共享的缓存区域
	具体步骤
	1. 父进程首先创建两个文件说明符3，4；3读取管道 4写入管道
	2. 为两个命令分别创建子进程，进程a 进程b，同时复制文件说明符
	3. 进程a 关闭自身标准输出说明符1，
	同时调用dup命令，将4管道写入说明符复制到最小的可用文件说明符，即文件说明符1，
	完成拷贝，后关闭进程a的说明符3，4
	4. 进程b 关闭自身标准输入 说明符0，
	同时调用dup命令，将3读取管道说明符复制到最小的可用文件说明符，即文件说明符0，
	完成拷贝，后关闭进程b的说明符3，4
	5. 之后进程a的标准输出进入到进程b的标准输入0 
	完成子进程间的通信


8. echo 命令 
	-e 开启字符串中的特殊字符功能，如变更字体颜色，不可见字符等


9. eval 命令
	1. eval ’‘|”“ 执行字符串内的可执行命令
	在命令行前加上eval时，shell就会在执行命令之前扫描它两次.eval命令将首先会先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。

	先对命令行中的变量进行替换，如果是可执行命令，则返回执行的结果

	例1 var='cat file'
	echo $var --> cat file
	eval $var --> file内的文件内容

	例2 返回最后一个参数，在文件中使用
	eval echo \$$# = eval ’echo \$$#‘ : \$是保持第一个$为自身，不转换成变量表示符
		eval 先将字符串翻译成 ”echo $参数的个数“， 之后执行 这个命令，得到最后一个参数

	例3 变量指针引用
	val=100
	ptr=val  --ptr 是val的指针
	eval echo \$$ptr => echo $var => 100
		如果只用echo $ptr => var
	如果通过ptr给val赋值 需要使用eval
	eval $ptr=40 => var=40 => var被设为40
		直接使用$ptr=40 则整体被视为一个commond，而不是赋值

	2. 与$(),` `反引号的区别
		$()与``是命令执行并返回结果，不进行变量替换

